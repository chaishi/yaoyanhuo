<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" href="/favicon.jpg"><title>yaoyanhuo</title><link href="/css/router.f5a5336d.css" rel="prefetch"><link href="/js/router.7db9e200.js" rel="prefetch"><link href="/css/app.3ec86574.css" rel="preload" as="style"><link href="/js/app.1b00deba.js" rel="preload" as="script"><link href="/js/chunk-vendors.feddb447.js" rel="preload" as="script"><link href="/css/app.3ec86574.css" rel="stylesheet"><link rel="stylesheet" type="text/css" href="/css/router.f5a5336d.css"><script charset="utf-8" src="/js/router.7db9e200.js"></script></head><body><noscript><strong>We're sorry but yaoyanhuo doesn't work properly without JavaScript enabled. Please enable it to continue.</strong></noscript><div id="app"><div class="head"><div class="head-inner g_page-container"><a href="/" class="router-link-active"><img src="/img/head.jpg"></a><div class="info"><h1 class="name">Yaoyanhuo 妖艳货</h1><span>Be a simple programmer. </span></div></div></div><div><div class="blog-detail g_page-container"><div class="markdown-body"><div class="markdown-to-vue-loader"><h1 id="中断和异常（操作系统）">中断和异常（操作系统）</h1><p><em>posted by yaoyanhuo on 2019-02-20</em></p><blockquote><p>中断（interrupt）指在程序执行过程中遇到急需处理的事件时，暂时中止现行程序在 CPU 上的运行，转而执行响应的事件处理程序，待处理完成后再返回断点或调度其他程序。本文主要对中断和异常的区别、中断优先级、中断处理程序和中断服务例程关系和常见几类中断进行描述。并以 Linux 系统作为中断例子，进一步了解中断机制和中断处理过程。</p></blockquote><p>举个生活中的例子，我爸让我 4:00 跟他一起打球，在这之前我一直在看电视，3:30 的时候我妈突然让我帮她整理衣服。如果在 4:00 之前，衣服整理完了，我就继续干自己的事儿，看电视。4:00 或 4:00 以后才整理完衣服，那就直接跟老爸去打球了。看看类比，</p><table><thead><tr><th>生活</th><th>电脑</th></tr></thead><tbody><tr><td>我</td><td>CPU</td></tr><tr><td>看电视</td><td>正在运行的程序</td></tr><tr><td>我妈让我整理衣服</td><td>中断请求</td></tr><tr><td>整理衣服</td><td>中断事件处理程序</td></tr><tr><td>老爸打球</td><td>其他定时调度程序</td></tr></tbody></table><h2 id="中断">中断</h2><p>由硬件发出或产生的中断成为硬中断，按硬中断事件的来源和实现手段可将中断划分为外中断和内中断。</p><p><strong>外中断，也是中断，异步中断</strong>，是指来自<u>处理器之外</u>的中断信号，包括时钟中断、键盘中断、它机中断和外部设备中断。外中断又分可屏蔽中断和不可屏蔽中断，各个中断具有不同的优先级，表示事件的紧急程度，在处理高一级中断时往往会部分或全部屏蔽低级中断。因最开始的中断仅针对外中断，因此外中断也直接称作中断。</p><h2 id="异常">异常</h2><p><strong>内中断，又称异常，同步中断</strong>，是指来自<u>处理器内部</u>的中断信号，通常是由于在程序执行过程中，发现与当前指令关联的、不正常的或错误的事件。内中断不能被屏蔽，一旦出现必须立即予以响应并进行处理，只是处理程序运行过程中可以选择是否屏蔽其它中断或屏蔽哪些中断。 内中断可细分为：</p><ol><li>访管中断，由系统程序执行访管指令引起，可以看做机器指令的一种扩充；</li><li>硬件故障中断，如：电源失效、奇偶校验错误，总线超时；</li><li>程序性中断，如：非法操作、地址越界、页面故障、调试指令、除数为0和浮点溢出等。</li></ol><h3 id="中断和异常的区别">中断和异常的区别</h3><table><thead><tr><th>分类</th><th>中断</th><th>异常</th></tr></thead><tbody><tr><td>产生地点</td><td>处理器外部，由与运行程序无关的中断信号触发，中断时间系统无法得知</td><td>处理器内部，CPU 控制单元产生</td></tr><tr><td>能否被屏蔽</td><td>高优先级的中断可以屏蔽低优先级的中断</td><td>不可被屏蔽</td></tr><tr><td>处理程序能否被阻塞</td><td>不能被阻塞，处理器需要及时响应其它中断信号</td><td>可以被阻塞</td></tr><tr><td>CPU</td><td>中断与 CPU 异步，无论处理器处于什么状态都需处理外部中断请求</td><td>异常与 CPU 同步，基本上发生在用户态，内核态唯一发生的异常是“缺页异常”</td></tr><tr><td>能否嵌套</td><td>允许嵌套，一般不超过 3 重，重数多了影响系统性能</td><td>大多为一重</td></tr><tr><td>彼此之间的影响</td><td>中断过程中绝不会产生异常</td><td>异常处理过程中可能会产生中断</td></tr></tbody></table><h4 id="为什么中断处理过程中不能被阻塞，而异常处理过程却可以？">为什么中断处理过程中不能被阻塞，而异常处理过程却可以？</h4><p>中断处理程序阻塞（或睡眠）后，不能进行进程调度，相当于免除干扰，也不响应其他中断请求，而“中断”要求被快速处理，以便响应其他中断信号，因此中断处理过程中不能被阻塞（或睡眠）。</p><p>而对于异常处理，异常所提供的服务本就是当前进程所需要的，故而当进程需要阻塞的时候，便会在异常处理程序中设置阻塞。</p><h4 id="为什么异常处理过程中可能会产生中断，但中断过程中绝不会产生异常-？">为什么异常处理过程中可能会产生中断，但中断过程中绝不会产生异常 ？</h4><p>中断产生于处理器外部，发生时机不受处理器内部限制，故而在处理器内部执行异常处理器程序的时候，可能产生中断（处理器外部）。异常产生于处理器内部，处理器内部正在进行中断处理时，不会同时在同一个处理器产生异常。</p><h2 id="中断和异常响应过程">中断和异常响应过程</h2><p>中断向量由硬件或操作系统预先分配和设置，系统调用所对应的向量则在访管指令中给出。用户程序通过访管指令找到对应的系统调用执行。异常向量则在 CPU 的硬件结构中预先预定。</p><p>一般来说，中断/异常的响应需要 <strong>顺序</strong> 做以下四件事，</p><ol><li><strong>发现中断源</strong>。在中断未被屏蔽的前提下，硬件发现中断/异常事件，并由CPU响应中断/异常请求。当发现多个中断源时，将根据预定的中断优先级先后响应中断请求。</li><li><strong>保护现场</strong>。暂停当前程序运行，硬件将中断点的现场信息（PSW）保存至核心栈，使得中断/异常处理程序在运行时不会破坏被中断程序中的有用信息，以便在处理完成后返回原程序继续运行。</li><li><strong>转向中断/异常事件处理程序执行</strong>。此时处理器状态已由用户态转为内核态，中断/异常处理程序开始工作。</li><li><strong>恢复现场</strong>。当中断处理结束后，恢复原运行程序的PSW，重新返回中断点以便执行后续指令。当异常处理结束后，返回点会因异常类型而异，大部分应用程序指令执行出错时，异常处理会结束进程，不可能回到原程序；如果执行访管指令，则异常处理完成后返回这条访管的下一条指令；对于页面故障，异常处理结束后会返回发生异常的那条指令重新执行。</li></ol><h4 id="操作如何转到中断异常处理程序执行的呢？">操作如何转到中断/异常处理程序执行的呢？</h4><p>对于中断处理程序，中断控制器发现中断源（外部设备、时钟部件或其它计算机发出）并产生中断，当前指令执行结束后， CPU 会检查中断寄存器（中断控制器的一部分）是否有中断事件发生，如果发现中断信号将暂停执行当前程序，转向执行内核的中断处理程序，如果没有发现中断信号，则继续执行当前程序。</p><p>对于异常处理程序，没有中断源一说，不使用中断控制器，是处理器在执行指令时本身发生的异常，指令控制逻辑和实现线路一旦发现异常变转向内核的异常处理程序。</p><h4 id="页面故障，异常处理结束后会返回发生异常的指令重新执行，那不会陷入死循环吗？">页面故障，异常处理结束后会返回发生异常的指令重新执行，那不会陷入死循环吗？</h4><p>不会，对于缺页异常，异常处理程序就是为了补页，页面补充好了，再继续执行之前的命令就不会发生缺页异常了。实在是糟糕，在异常处理程序中发现没有页可以补了，就需要阻塞调入，进行页面置换，如果依旧没有可用页面了，那就是页面挂了。</p><h4 id="什么是访管指令？">什么是访管指令？</h4><blockquote><p>访管指令是可以在<strong>目态</strong>下执行的指令。当源程序中有需要操作系统服务的要求时，编译程序就会在由源程序转换成的目标程序中安排一条“访管指令”并设置一些参数。当目标程序执行时，中央处理器若取到了“访管指令”就产生一个中断事件，中断装置就会把中央处理器转换成管态，并让操作系统处理该中断事件。操作系统分析访管指令中的参数，然后让相应的“系统调用”子程序为用户服务。系统调用功能完成后，操作系统把中央处理器的管态改为目态，并返回到用户程序。 —— 百度百科</p></blockquote><p>访管指令不是特权指令。</p><p>访管指令的意义在于让没有办法在目态下完成的工作，可通过访管指令请求内核系统执行完成并返回到用户程序。访管中断正是因访管指令的执行而产生。</p><p>按照个人理解，应用程序请求系统调用（操作系统服务）需要访管指令牵线搭桥。访问指令相当于店里管钱的，下面的人需要资金的时候就向管事的申请，批下来后，钱就能到申请人的手里了。好比说，要执行某个任务，虽说自己没钱，但可以通过管钱的人员向店长申请，最终钱依旧能到手。</p><h2 id="中断优先级">中断优先级</h2><p>此处的中断为外中断，异常没有优先级一说，大多为一重。中断优先级可以按照中断请求的轻重缓急程度和设备运行速度快慢来界定，在中断装置中预设。如果系统正在执行某优先级的中断服务例程，那么只有更高优先级的中断请求才能中断此服务例程。</p><p><strong>中断屏蔽</strong>是指 禁止 CPU 响应或禁止中断产生。前者是指 CPU 暂时不响应中断，等中断开放了被屏蔽的中断才能被响应，防止同级或高级的中断影响。后者是中断的事件发生时直接不允许提出中断请求也不能通知 CPU。好比， A 想找 B 帮忙，找到 B 之后，由于 B 正在忙很重要的事情，没工夫搭理，答应 A 等他忙完就帮 A 处理，这种情况属于 B 忙的时候禁止处理其它事情。再看， A 想找 C 帮忙，可是 C 提前在朋友圈说，最近出国旅游了根本没法帮忙，由此 A 即使有紧急的问题也不会告诉 C 了。</p><p>多重中断有几种处理方法，一种是串行处理，CPU 响应中断的时候屏蔽其它部分或所有中断；第二种是即时处理，运行中断的过程中，如果出现程序性中断（异常），一般情况表明此时中断处理程序有异常，应对其进行立即响应；第三种是嵌套处理，对于有些必须处理的高优先级的中断事件，采用屏蔽的方法不妥，因此允许某些中断处理程序时依然能够响应中断。<strong>操作系统</strong>必须预先规定每类中断的优先级，中断嵌套一般不会超过 3 重，过多嵌套会增加系统不必要的开销。</p><h2 id="中断处理程序和中断服务例程">中断处理程序和中断服务例程</h2><p><img src="http://img.yaoyanhuo.com/interrupt_01.png" alt="中断处理程序"></p><p>如图，由于硬件限制，中断控制器的一条中断线会对接多个设备（图中为打印机）。而这一条中断线仅仅对应一个中断处理程序，那一个中断处理程序如何应对多台设备呢？这台打印机可能要打印，那台打印机可能要复印。这不，就出现了 中断服务例程，每台设备（打印机）都有自己的中断服务例程，各自完成自己的任务。</p><p>中断线上产生中断信号时，中断控制器会把收到的 IRQ 号转成向量号。当中断请求到达时，进入中断处理程序，程序根据 IRQ 号和设备号即可定位到哪台机器产生的中断请求，然后执行相应的中断服务例程。可见，中断处理程序仅仅相当于一个通道，实际上的中断处理在中断服务例程中完成，一个中断处理程序对应了若干个中断服务例程。</p><h2 id="常见中断">常见中断</h2><h3 id="硬件故障中断">硬件故障中断</h3><p>硬件故障中断属于异常的一种，一般由硬件故障导致，如电源故障、内存故障、设备故障。中断处理程序主要是保护现场，停止设备工作，停止处理器运行，报告故障信息等。</p><h3 id="程序性中断">程序性中断</h3><p>程序性中断也属于异常的一种，主要有一下几类错误，语法错误、逻辑错误和运行过程中产生的异常。语法错误由编译程序发现并报错，逻辑错误由测试程序发现并报错，定点溢出和除数为 0 会产生运行中异常。异常不同处理程序也会因实际需求而不同，因此，操作系统捕获的这类中断事件是原封不动地交由应用程序自行处理。</p><h3 id="访管中断">访管中断</h3><p>访管中断是由程序执行访管指令而引起的，访管指令包括操作码和访管参数，前者表示该指令是访管指令，后者表示具体的访管要求，不同的访管参数对应不同的服务要求。</p><p>系统调用通过访管指令和中断机制来实现，不同的机器有不同的系统调用格式和功能号，但都有如下机器共性处理流程，</p><ol><li>程序执行访管指令，并通过适当的方式指明系统调用号</li><li>通过中断机制进入访管中断处理程序，现场信息被保护到核心栈，按功能号跳转</li><li>通过系统调用入口地址表找到响应中断服务例程的入口地址</li><li>执行中断服务例程，正常情况下执行结束后返回系统调用的下一条指令继续执行</li></ol><h3 id="时钟中断">时钟中断</h3><p>时钟分为绝对时钟和间隔时钟，是操作系统进行调度的重要工具，负责维护系统绝对时间和日期，让分时进程按时间片轮转，让实时进程定时发送或接受控制信号等。陷入死循环的进程最终会因时间片耗尽而被迫让出处理器。</p><p>对于<strong>绝对时钟</strong>，系统会设置一个绝对时钟寄存器，定时的把寄存器的内容加 1，如果寄存器的初始内容是 0，那么就可以根据系统开机时间计算出当前时间。从 Linux V2.5 开始，时钟中断频率已经提高至 1000 Hz，即每 1 ms 产生一次 1 次时钟中断。</p><p><strong>间隔时钟</strong>寄存器处理则刚好相反，每个时间切换点内容会减 1，内容减到 0 时，就会产生间隔时钟中断。通过程序设置初始寄存器初始值。如果进程需要延迟执行，也可通过系统调用将间隔时钟设为挂起状态，等到时钟中断产生，操作系统就会唤起该进程。</p><p>有了硬件定时器，系统就可以记录进程的创建时间及进程在生命周期内占用 CPU 的时间。<code>ps -o</code>能查看某 Linux 系统某进程的开始时间、结束时间和运行时间。</p><pre><code>[~]$ ps -o stime,etime,time 32254
STIME     ELAPSED     TIME
Jan10 40-08:11:15 00:26:31</code></pre><p>Linux 系统运行了不同的间隔定时器： real、virtual、profile，分别统计不同状态的耗时。在进程中同时设定这三个定时器，就可以了解进程在用户态、内核态和总的执行时间。</p><table><thead><tr><th>间隔定时器</th><th>描述</th></tr></thead><tbody><tr><td>real</td><td>按实际经过的时间计时，无论进程处于何种状态（包括挂起），计时总在进行，当定时到达时发送给进程一个 <code>SIGALARM</code> 信号</td></tr><tr><td>virtual</td><td>仅在处理器处于用户态执行进程时计时，当定时到达时发送给进程一个 <code>SIGVTALARM</code> 信号</td></tr><tr><td>profile</td><td>进程执行在用户态和内核态都计时，当定时到达时发送给进程一个 <code>SIGROF</code> 信号</td></tr></tbody></table><h2 id="linux-系统中断">Linux 系统中断</h2><h3 id="内核处理流程">内核处理流程</h3><p>Linux 系统中，进程在用户态执行，发出系统调用请求或产生中断/异常时，促使处理器转换为内核态，内核开始工作。下图为 Linux 内核处理流程，可先了解大概运行规律。</p><p><img src="http://img.yaoyanhuo.com/Linux%20%E5%86%85%E6%A0%B8%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png" alt="Linux 内核处理流程"></p><p>异常处理结束后会从 <code>ret_from_exception</code> 退出，中断处理结束后会从 <code>ret_from_intr()</code> 退出，系统调用会从系统调用退出。当它们退出后，都会转到一个很重要的过程 <code>ret_from_sys_call</code> 执行。该方法会处理如图所示的慢中断下半部分调度、积累的信号处理、<code>TIF_NEED_RESCHED</code>置位检查等。</p><h3 id="中断处理机制">中断处理机制</h3><p>Intel x86 机器共支持 256 种信号，从 0 ~ 255 编号，这 8 位无符号整数称为一个<strong>中断向量</strong>。系统会分别为异常、非屏蔽中断、屏蔽中断、软中断、系统调用分配对应的中断向量。异常和非屏蔽中断的向量是固定的，而屏蔽中断的向量可以通过中断控制器编程改变。非屏蔽中断和异常一样，不可被屏蔽。</p><table><thead><tr><th>编号</th><th>分配</th></tr></thead><tbody><tr><td>0 ~ 31</td><td>异常和非屏蔽中断向量</td></tr><tr><td>32 ~ 47</td><td>屏蔽中断</td></tr><tr><td>48 ~ 255</td><td>软中断，其中第 <code>128</code> 号（0x80）用来实现系统调用</td></tr></tbody></table><p>在 Linux 系统中，每个能发送中断信号的硬件设备控制器都有一根输出线，与中断控制器 8259A 的输入引脚相连，如下图 设备1 和 设备 3 所示。图中有两个 8259A 芯片共同组成中断控制器，每个芯片有 8 个输入端，一共可以扩展到 15 个中断源，多数情况下，15 个也是不够用的，因此系统会让多个设备共有一条中断线或动态分配中断线。</p><h4 id="为什么各有-8-个输入端，最后只能扩展到-15-个中断源呢？">为什么各有 8 个输入端，最后只能扩展到 15 个中断源呢？</h4><p>为了保证两个芯片连起来成为一个中断控制器，其中一个芯片的一个输入端要接另一个芯片。</p><p><img src="http://img.yaoyanhuo.com/%E4%B8%AD%E6%96%AD%E4%BF%A1%E5%8F%B7.png" alt="中断机制"></p><p>上图描述了中断控制器如何在设备和 CPU 之间传递中断请求。通过输入端接收中断信号，随后通过 INT 引脚向 CPU 发送中断信号请求，同时，输入端产生的 IRQ 号，经内部处理后 <u>IRQ 号转换成中断向量号</u>，放入某端口，等待 CPU 响应时来取。</p><p>知道了中断信号的传输情况，再看看中断发生之前需要做些什么。</p><p>Linux 内核初始化中断相关的工作有：初始化可编程中断控制器 8259A 、将 IDT 表的起始地址装入 IDTR 寄存器、初始化 IDT 中断门描述符。</p><p>Linux 中断机制在保护模式下采用<strong>中断描述符表（Interrupt Descriptor Table, IDT）</strong>，其表项被成为门描述符（gate descriptor），一个表项对应一个中断/异常。该表保存中断向量号对应的门描述符以及门描述符对应的中断程序入口地址。</p><p>由于一个中断处理程序（一条中断线）对应多个中断服务例程，因此 Linux 系统为每个中断请求 IRQ 设置了一个中断请求队列，用 <code>irq_desc_r</code> 描述，成为 IRQ 描述符，若干 irq 再组成一个数组。中断线共享的数据结构是<code>irqaction</code>， 包含中断服务例程 handler、 IRQ 号、设备号以及其它特征位和链接指针。 IDT 表的初始化后，每个中断服务队列依旧是空的，需要初始化设备驱动程序的时候调用 <code>request_irq()</code> 注册中断服务例程，当卸载设备驱动程序时，调用 <code>free_irq()</code> 注销中断服务例程，并释放中断线。</p><p>中断处理程序的执行过程如图所示，</p><p><img src="http://img.yaoyanhuo.com/Linux%20%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B.png" alt="中断处理过程"></p><p>中断处理程序要做很多工作，如果整个过程全部屏蔽，容易产生中断请求丢失的情况，由此，Linux 中断处理程序被划分为上半部分和下半部分两个处理函数。中断向量表中登记的中断处理程序入口地址是上半部分，上半部分接收到中断立即开始工作，要决定其相关的下半部分是否执行，期间不可能被中断。为了更快地处理所有到来的其他中断，耗时的工作就需要放到下半部分进行处理，下半部分的执行是可以中断的，如果运行期间出现新的中断，则下半部分先暂停，等到新出现的中断上半部分运行完成后再回来继续执行之前的下半部分。</p><p>有个类似的生活中的例子，去医院看病，先挂号再看诊。挂号是不可中断的，只有一个人挂完了才能给下一个人挂号，而且速度比较快；挂号后找对应医师开始看诊，看诊过程消耗时间比较长，可以被中断，比如有些反诊病人可以直接进入医务室看诊，医师稍有空就会帮反诊病人看一下，结束后医师继续看诊之前的病人。</p><h2 id="参考文献">参考文献</h2><p>《操作系统教程》第 5 版 . 费翔林 骆斌 . 编著，在回顾阅读过程中同时咨询操作系统老师（贾小林）</p></div></div></div></div><footer><a href="http://www.beian.miit.gov.cn" target="_blank">.沪ICP备19007658号. </a>&nbsp;
  <a href="http://www.yaoyanhuo.com">www.yaoyanhuo.com</a>  . Connect me by email yaoyanhuoyi@qq.com
</footer></div><script src="/js/chunk-vendors.feddb447.js"></script><script src="/js/app.1b00deba.js"></script></body></html>